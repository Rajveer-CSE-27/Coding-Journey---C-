// || जय जय जय बजरंग बली ||

#include <bits/stdc++.h>
using namespace std;
#define int long long

/**
https://www.youtube.com/watch?v=OCKvEMF0Xac&list=PLDV1Zeh2NRsDGO4--qE8yH72HFL1Km93P&index=11
https://cses.fi/problemset/task/1700

Isomorphic trees :: 
    -> Definition :: Two trees/graphs who may be labelled differently but are structurally same are called isomorphic trees/graphs.
    -> Approach :: 
            Serializing a tree into a unique encoding.
            This will be simply a unique string that represents a tree.
            If two trees have same encoding then they both are isomorphic.
            
            Serializing a rooted tree is easier code wise.
            
            If we are going to root our two trees to check if they are isomorphic is to ensure that same root node is selected in both the trees before encoding the trees.
            If we serialize both tree's from their centre node then if 2 trees are isomorphic then we will generate same strings.
            
            Hence if tree1 has centre n1,n2 and tree2 has centre n11,n22 then ::
                    String generated by n1 will be equal to that generated by either n11 or n22 for sure if 2 trees are isomorphic.
                    
    -> Serializing a tree from a root node :: 
            The tree encoding is simply a sequence of left '(' and right ')' brackets.
            However, you can also think of them as 1's and O's if you prefer. (We will prefer becuase we can generate a number out of that binary string and sorted order of numbers is easier to process then that of strings); See last lines of this blog :: https://codeforces.com/blog/entry/101010
            
            It is also possible to construct the tree from the string, this is called deserializing.
            
    -> AHU(Aho, Hopcroft, Ullman) algorithm to serialize a rooted tree ::
            Start by assigning all leaf nodes '()'
            For each node, combine the strings generated by each of its child node and wrap them in brackets.
            See video :: 6:59
            NOTE :: children strings get sorted when combined, this is important. (this will only help us to find isomorphic trees).
            

For code :: https://codeforces.com/blog/entry/101010 see the blog.
The above code uses 1 and 0 based so look at my code

Time :: O(nlogn)
**/



vector<int> find_center(vector<vector<int>>& tree, int n) {
    
    vector<int> degree(n+1);
    vector<int> leaf;
    vector<bool> vis(n+1,false);
    vector<int> ans;
    
    for(int i=1; i<=n; i++) {
        degree[i] = tree[i].size();
        if(degree[i] == 0) {
            ans.push_back(i);
            return ans;
        } else if(degree[i] == 1) { // leaf
            leaf.push_back(i);
            vis[i] = true;
        }
    }
    
    while(true) {
        vector<int> leaf2;
        
        for(int l:leaf) {
            vector<int> temp = tree[l];
            for(int adj:temp) {
                if(vis[adj] == false) {
                    degree[adj]--;
                    if(degree[adj] == 1) {
                        leaf2.push_back(adj);
                        vis[adj] = true;
                    }
                }
            }
        } 
        if(leaf2.size() == 0) { // no more nodes in tree to visit
            break;
        }
        leaf = leaf2;
    }
    
    return leaf;
}


bool comp(string s1, string s2) {
    if(s1.length() < s2.length()) {
        return true;
    }
    if(s1.length() > s2.length()) {
        return false;
    }
    
    // sort acc to first occurence of )
    for(int i=0; i<s1.length(); i++) {
        if(s1[i] != s2[i]) {
            if(s1[i] == ')') {
                return true;
            } else {
                return false;
            }
        }
    }
    return true;
}

string generate_sequence(int root, int parent, vector<vector<int>>& tree) {
    
    vector<string> child_sequences;
    
    for(int child:tree[root]) {
        if(child != parent) {
            string temp = generate_sequence(child, root, tree);
            if(temp.length() > 0) {
                child_sequences.push_back(temp);
            }
        }
    }
    
    sort(child_sequences.begin(), child_sequences.end(), comp);
    
    string res;
    for(string s:child_sequences) {
        res += s;
    }
    res += ")";
    res = "(" + res;
    
    return res;
    
}

void solve() { 
    int n;
    cin >> n;
    
    vector<vector<int>> tree1(n+1), tree2(n+1);
    
    for(int i=0; i<n-1; i++) {
        int n1,n2;
        cin >> n1 >> n2;
        tree1[n1].push_back(n2);
        tree1[n2].push_back(n1);
    }
    
    for(int i=0; i<n-1; i++) {
        int n1,n2;
        cin >> n1 >> n2;
        tree2[n1].push_back(n2);
        tree2[n2].push_back(n1);
    }
    
    vector<int> center1 = find_center(tree1,n);
    vector<int> center2 = find_center(tree2,n);
    
    string s1 = generate_sequence(center1[0], 0, tree1);
    
    for(int c:center2) {
        string s = generate_sequence(c, 0, tree2);
        if(s == s1) {
            cout << "YES";
            return;
        }
    }
    
    cout << "NO"; 
    
}


signed main() {
    
    int tc = 1;
    cin >> tc;
    while(tc--) {
        solve();
        cout << '\n';
    }
    
    return 0;
}
